# 计算机网络



## 分层结构



![img](MarkDown_Computer%20Networks.assets/aHR0cDovL3d3MS5zaW5haW1nLmNuL2xhcmdlLzAwNUY0OGdibHkxZzQxdm1nanUzdWozMGwyMGI3d2dmLmpwZw-1615731937573)





## 应用层



### URI与URL



统一资源标志符URI就是在某一规则下能把一个资源独一无二地标识出来。
拿人做例子，假设这个世界上所有人的名字都不能重复，那么名字就是URI的一个实例，通过名字这个字符串就可以标识出唯一的一个人。
现实当中名字当然是会重复的，所以身份证号才是URI，通过身份证号能让我们能且仅能确定一个人。
那统一资源定位符URL是什么呢。也拿人做例子然后跟HTTP的URL做类比，就可以有：

动物住址协议://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三.人

可以看到，这个字符串同样标识出了唯一的一个人，起到了URI的作用，所以URL是URI的子集。URL是以描述人的位置来唯一确定一个人的。
在上文我们用身份证号也可以唯一确定一个人。对于这个在杭州的张三，我们也可以用：

身份证号：[123456789](tel:123456789)

来标识他。
所以不论是用定位的方式还是用编号的方式，我们都可以唯一确定一个人，都是URl的一种实现，而URL就是用定位的方式实现的URI。

回到Web上，假设所有的Html文档都有唯一的编号，记作html:xxxxx，xxxxx是一串数字，即Html文档的身份证号码，这个能唯一标识一个Html文档，那么这个号码就是一个URI。
而URL则通过描述是哪个主机上哪个路径上的文件来唯一确定一个资源，也就是定位的方式来实现的URI。
对于现在网址我更倾向于叫它URL，毕竟它提供了资源的位置信息，如果有一天网址通过号码来标识变成了[http://741236985.html](https://link.zhihu.com/?target=http%3A//741236985.html)，那感觉叫成URI更为合适，不过这样子的话还得想办法找到这个资源咯…







### HTTP

https://blog.csdn.net/zhangliangzi/article/details/51336564







## 传输层



### TCP 与 UDP

https://leetcode-cn.com/circle/discuss/b4PW9S/

#### TCP 基本认识

![image-20210313001710392](MarkDown_Computer%20Networks.assets/image-20210313001710392-1615731941746.png)

![TCP 头格式](MarkDown_Computer%20Networks.assets/1616140750-tkQhoX-file_1616140748676)

 **序列号**seq：占4个字节，在建立连接时由计算机生成的随机数作为其初始值，第一个字节的编号由本地随机产生，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来**解决网络包乱序问题**。

**确认应答号**ack：占4个字节，指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来**解决不丢包的问题**。



**控制位**：

**ACK**：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。
RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
**SYN**：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。
**FIN**：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。







`IP` 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。

![OSI 参考模型与 TCP/IP 的关系](MarkDown_Computer%20Networks.assets/1616140750-DErUYb-file_1616140748710)

如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。

因为 TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是**无损坏、无间隔、非冗余和按序**的。

TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议。

面向连接：**一定是「一对一」才能连接**，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；

**可靠的**：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；

**字节流**：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，**当「前一个」消息没有收到的时候，即使它先收到了后面的字节，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃**。





##### **什么是 TCP 连接？**

我们来看看 RFC 793 是如何定义「连接」的：

Connections:
The reliability and flow control mechanisms described above require
that TCPs initialize and maintain certain status information for
each data stream. The combination of this information, including
sockets, sequence numbers, and window sizes, is called a connection.

简单来说就是，用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括**Socket、序列号和窗口大小**称为连接。



##### **如何唯一确定一个 TCP 连接呢？**

TCP 四元组可以唯一的确定一个连接，四元组包括如下：

源地址
源端口
目的地址
目的端口

![TCP 四元组](MarkDown_Computer%20Networks.assets/1616140750-XDKUcL-file_1616140748725)


源地址和目的地址的字段（32位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。

源端口和目的端口的字段（16位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。



##### **有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？**

服务器通常固定在某个本地端口上监听，等待客户端的连接请求。

因此，客户端 IP 和 端口是可变的，其理论值计算公式如下:

![img](MarkDown_Computer%20Networks.assets/1616140750-LTnFAm-file_1616140748583)

对 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最大 TCP 连接数，约为 2 的 48 次方。

当然，服务端最大并发 TCP 连接数远不能达到理论上限。

首先主要是文件描述符限制，Socket 都是文件，所以首先要通过 ulimit 配置文件描述符的数目；
另一个是内存限制，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的。





#### **UDP 和 TCP 有什么区别呢？分别的应用场景是？**

UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。

UDP 协议真的非常简，头部只有 8 个字节（ 64 位），UDP 的头部格式如下：

![UDP 头部格式](MarkDown_Computer%20Networks.assets/1616140750-GcrCSE-file_1616140748889)

目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。
包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。
校验和：校验和是为了提供可靠的 UDP 首部和数据而设计



##### TCP 和 UDP 区别：

1. 连接

TCP 是面向连接的传输层协议，传输数据前先要建立连接。
UDP 是不需要连接，即刻传输数据。
2. 服务对象

TCP 是一对一的两点服务，即一条连接只有两个端点。
UDP 支持一对一、一对多、多对多的交互通信
3. 可靠性

TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。
UDP 是尽最大努力交付，不保证可靠交付数据。
4. 拥塞控制、流量控制

TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。
5. 首部开销

TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。
UDP 首部只有 8 个字节，并且是固定不变的，开销较小。
6. 传输方式

TCP 是流式传输，没有边界，但保证顺序和可靠。
UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。
7. 分片不同

TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了一个分片，则就需要重传所有的数据包，这样传输效率非常差，所以通常 UDP 的报文应该小于 MTU。



##### TCP 和 UDP 应用场景：

由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：

FTP 文件传输
HTTP / HTTPS
由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：

包总量较少的通信，如 DNS 、SNMP 等
视频、音频等多媒体通信
广播通信
为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？

原因是 TCP 有可变长的「选项」字段，而 UDP 头部长度则是不会变化的，无需多一个字段去记录 UDP 的首部长度。

为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？

先说说 TCP 是如何计算负载数据长度：



其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。

大家这时就奇怪了问：“ UDP 也是基于 IP 层的呀，那 UDP 的数据长度也可以通过这个公式计算呀？ 为何还要有「包长度」呢？”

这么一问，确实感觉 UDP 「包长度」是冗余的。

因为为了网络设备硬件设计和处理方便，首部长度需要是 4 字节的整数倍。

如果去掉 UDP 「包长度」字段，那 UDP 首部长度就不是 4 字节的整数倍了，所以小林觉得这可能是为了补全 UDP 首部长度是 4 字节的整数倍，才补充了「包长度」字段。





 

#### TCP有限状态机

![img](MarkDown_Computer%20Networks.assets/20180608201426603)













#### 三次握手

![image-20210313001658266](MarkDown_Computer%20Networks.assets/image-20210313001658266-1615731945174.png)

三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了**确认双方的接收能力和发送能力是否正常**、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器**指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息**。

![TCP 三次握手](MarkDown_Computer%20Networks.assets/1616140750-FadmSh-file_1616140748635)



- 一开始，客户端和服务端都处于 `CLOSED` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态

![第一个报文—— SYN 报文](MarkDown_Computer%20Networks.assets/1616140750-jCbEyW-file_1616140748904)

客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1 ，**表示 SYN 报文**。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该**报文不包含应用层数据**，之后客户端处于 **SYN-SENT** 状态。**SYN=1的报文段不能携带数据，但要消耗掉一个序号。**



![第二个报文 —— SYN + ACK 报文](MarkDown_Computer%20Networks.assets/1616140750-AYtmBt-file_1616140748642)



服务端收到客户端的 SYN 报文后，首先服务端也**随机初始化自己的序号**（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 **client_isn + 1**, 接着把 **SYN 和 ACK 标志位置为 1**。最后把该报文发给客户端，该报文也**不包含应用层数据**，之后服务端处于 **SYN-RCVD** 状态。



![第三个报文 —— ACK 报文](MarkDown_Computer%20Networks.assets/1616140750-yFcdIM-file_1616140748704)



客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 **server_isn + 1** ，客户端会初始化序号加一（**client_isn + 1**），将此序号置于 TCP 首部的「序号」字段中，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 **ESTABLISHED** 状态。

服务器收到客户端的应答报文后，也进入 ESTABLISHED 状态。从上面的过程可以发现第三次握手是可以携带数据的，前两次握手是不可以携带数据的，**ACK报文段可以携带数据，不携带数据则不消耗序号**。

这也是面试常问的题。

一旦完成三次握手，双方都处于 ESTABLISHED 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。



#### 如何在 Linux 系统中查看 TCP 状态？

TCP 的连接状态查看，在 Linux 可以通过 `netstat -napt` 命令查看。

![TCP 连接状态查看](MarkDown_Computer%20Networks.assets/1616140750-hTbnlZ-file_1616140748643)



#### 为什么是三次握手？不是两次、四次？

什么是 **TCP 连接**：

- 用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括**Socket、序列号和窗口大小**称为连接。

为什么三次握手才可以初始化Socket、序列号和窗口大小并建立 TCP 连接。

接下来以四个方面分析三次握手的原因：

**三次握手才可以阻止重复历史连接的初始化（主要原因）**

**三次握手才可以同步双方的初始序列号**

**三次握手才可以避免资源浪费**

**三次握手才能保证双方具有接收和发送的能力**



##### 原因一：避免历史连接

我们来看看 RFC 793 指出的 TCP 连接使用三次握手的首要原因：

The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.

简单来说，三次握手的首要原因是**为了防止旧的重复连接初始化造成混乱。**

网络环境是错综复杂的，往往并不是如我们期望的一样，先发送的数据包，就先到达目标主机，反而它很骚，可能会由于网络拥堵等乱七八糟的原因，会使得旧的数据包，先到达目标主机，那么这种情况下 TCP 三次握手是如何避免的呢？

![三次握手避免历史连接](MarkDown_Computer%20Networks.assets/1616140750-JaRoLY-file_1616140748632)



客户端连续发送多次 SYN 建立连接的报文，在网络拥堵情况下：

一个**「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端**；
那么此时服务端就会回一个 SYN + ACK 报文给客户端；
客户端收到后可以根据自身的上下文，**判断这是一个历史连接（序列号过期或超时）**，**那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。**
如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：

如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 RST 报文，以此中止历史连接；
如果不是历史连接，则第三次发送的报文是 ACK 报文，通信双方就会成功建立连接；
所以，TCP 使用三次握手建立连接的**最主要原因是防止历史连接初始化了连接**。



##### 原因二：同步双方初始序列号

TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：

接收方可以去除重复的数据；
接收方可以根据数据包的序列号按序接收；
可以标识发送出去的数据包中， 哪些是已经被对方收到的；
可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样**一来一回，才能确保双方的初始序列号能被可靠的同步**。

![四次握手与三次握手](MarkDown_Computer%20Networks.assets/1616140750-qZUzPR-file_1616140748735)

四次握手其实也能够可靠的同步双方的初始化序号，但由于第二步和第三步可以优化成一步，所以就成了「三次握手」。

而**两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收**。



##### 原因三：避免资源浪费

如果只有「**两次握手**」，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，**服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号，所以每收到一个 SYN 就只能先主动建立一个连接**，这会造成什么情况呢？

如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。

![两次握手会造成资源浪费](MarkDown_Computer%20Networks.assets/1616140750-ZbUysW-file_1616140748620)

即两次握手会造成消息滞留情况下，服务器重复接受无用的连接请求 SYN 报文，而造成重复分配资源。



##### 原因四：对双方收发能力的确认

第一次握手：客户端发送网络包，服务端收到了。这样**服务端**就能得出结论：**客户端的发送能力**、**服务端的接收能力**是正常的。

第二次握手：服务端发包，客户端收到了。这样**客户端**就能得出结论：**服务端的接收**、**发送能力**，**客户端(自己)的接收**、**发送能力**是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。

第三次握手：客户端发包，服务端收到了。这样**服务端**就能得出结论：**客户端的接收、发送能力正常，服务器自己的发送、接收能力**也正常。

因此，**需要三次握手才能确认双方的接收与发送能力是否正常**。



##### **小结**

TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。

不使用「两次握手」和「四次握手」的原因：

「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。



#### 为什么客户端和服务端的初始序列号 ISN 是不相同的？

如果一个已经失效的连接被重用了，但是该旧连接的历史报文还残留在网络中，如果序列号相同，那么就无法分辨出该报文是不是历史报文，如果历史报文被新的连接接收了，则会产生数据错乱。

所以，每次建立连接前重新初始化一个序列号主要是为了通信双方能够根据序号将不属于本连接的报文段丢弃。

另一方面是为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收。



#### 初始序列号 ISN 是如何随机产生的？

起始 ISN 是基于时钟的，每 4 毫秒 + 1，转一圈要 4.55 个小时。

RFC1948 中提出了一个较好的初始化序列号 ISN 随机生成算法。

ISN = M + F (localhost, localport, remotehost, remoteport)

M 是一个计时器，这个计时器每隔 4 毫秒加 1。
F 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。



#### 既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？

我们先来认识下 MTU 和 MSS

![MTU 与 MSS](MarkDown_Computer%20Networks.assets/1616140750-frxIPU-file_1616140748600)

- `MTU`：一个网络包的最大长度，以太网中一般为 `1500` 字节；
- `MSS`：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；

如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，会有什么异常呢？

当 IP 层有一个**超过 MTU 大小**的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，再交给上一层 TCP 传输层。

这看起来井然有序，但这存在隐患的，那么当**如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传**。

因为 **IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。**

当**接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。**

因此，可以得知由 IP 层进行分片传输，是非常没有效率的。

如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，会有什么异常呢？

当 IP 层有一个超过 MTU 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，再交给上一层 TCP 传输层。

这看起来井然有序，但这存在隐患的，那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传。

因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。

当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。

因此，可以得知由 IP 层进行分片传输，是非常没有效率的。



所以，为了达到最佳的传输效能 TCP 协议**在建立连接的时候通常要协商双方的 MSS 值**，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。

![握手阶段协商 MSS](MarkDown_Computer%20Networks.assets/1616140750-AJQwVl-file_1616140748579)

经过 TCP 层分片后，如果一个 TCP 分片丢失后，**进行重发时也是以 MSS 为单位**，而不用重传所有的分片，大大增加了重传的效率。





#### 什么是 SYN 攻击？如何避免 SYN 攻击？

SYN 攻击

我们都知道 TCP 连接建立是需要三次握手，假设**攻击者短时间伪造不同 IP 地址的 SYN 报文**，**服务端每接收到一个 SYN 报文，就进入SYN_RCVD** 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会**占满服务端的 SYN 接收队列（未连接队列）**，使得服务器不能为正常用户服务。

![SYN 攻击](MarkDown_Computer%20Networks.assets/1616140750-pAFWWK-file_1616140748612)





**避免 SYN 攻击方式一**

其中一种解决方式是通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理。

当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数：

```shell
net.core.netdev_max_backlog
```


SYN_RCVD 状态连接的最大个数：

```shell
net.ipv4.tcp_max_syn_backlog
```

**超出处理能时，对新的 SYN 直接回报 RST，丢弃连接**：

```sh
net.ipv4.tcp_abort_on_overflow
```



***避免 SYN 攻击方式二***

我们先来看下 Linux 内核的 `SYN` （未完成连接建立）队列与 `Accpet` （已完成连接建立）队列是如何工作的？

![正常流程](MarkDown_Computer%20Networks.assets/1616140750-bGESDU-file_1616140748798)

正常流程：

当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；
接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；
服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；
应用通过调用 accpet() socket 接口，从「 Accept 队列」取出连接。

![应用程序过慢](MarkDown_Computer%20Networks.assets/1616140750-xuxePE-file_1616140748826)



应用程序过慢：

- 如果应用程序过慢时，就会导致「 Accept 队列」被占满。



![受到 SYN 攻击](MarkDown_Computer%20Networks.assets/1616140750-tjCYqW-file_1616140748553)

受到 SYN 攻击：

- 如果不断受到 SYN 攻击，就会导致「 SYN 队列」被占满。

```shell
net.ipv4.tcp_syncookies = 1
```

![tcp_syncookies 应对 SYN 攻击](MarkDown_Computer%20Networks.assets/1616140750-VkMrRC-file_1616140748674)



当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；
计算出一个 cookie 值，再以 SYN + ACK 中的「序列号」返回客户端，
服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」。
最后应用通过调用 accpet() socket 接口，从「 Accept 队列」取出的连接。

















#### 四次挥手

![image-20210313002014727](MarkDown_Computer%20Networks.assets/image-20210313002014727-1615731947816.png)

双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。



1.客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1）,之后客户端进入 FIN_WAIT_1 （终止等待1）状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

2.服务端收到该报文后，就向客户端发送 ACK 应答报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

3.客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 （终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。

4.等待服务端处理完数据后，也向客户端发送 FIN 报文，FIN=1，ack=u+1之后服务端进入 LAST_ACK（最后确认）状态，等待客户端的确认。

5.客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。

6.服务器收到了 ACK 应答报文后，就进入了 CLOSED 状态，至此服务端已经完成连接的关闭，可以看到，服务器结束TCP连接的时间要比客户端早一些。。

7.客户端在经过 2MSL 一段时间后，自动进入 CLOSED 状态，至此客户端也完成连接的关闭。









##### 【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？

答：因为当**Server端收到Client端的SYN连接请求报文**后，可以**直接发送SYN+ACK报文**。其中**ACK报文是用来应答的，SYN报文是用来同步的**。但是关闭连接时，**当Server端收到FIN报文时**，很可能并不会立即关闭SOCKET，所以**只能先回复一个ACK报文**，告诉Client端，"**你发的FIN报文我收到了**"。**只有等到我Server端所有的报文都发送完了，我才能发送FIN报文**，因此不能一起发送。故需要四步握手。



##### 【问题2】为什么TIME_WAIT状态需要经过2MSL(**最大报文段生存时间**)才能返回到CLOSE状态？

见为什么需要TIME_WAIT状态

 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以**一来一回需要等待 2 倍的时间**。比如如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。

2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计时。

在 Linux 系统里 2MSL 默认是 60 秒，那么一个 MSL 也就是 30 秒。Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒。

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。**如果在该时间内再次收到FIN**，**那么Client会重发ACK并再次等待2MSL**。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。



##### 为什么需要 TIME_WAIT 状态？

主动发起**关闭连接的一方，才会有 TIME-WAIT 状态**。

需要 TIME-WAIT 状态，主要是两个原因：

**1.防止具有相同「四元组」的「旧」数据包被收到；**

**2.保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；**

**原因一：防止旧连接的数据包**

假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？

![接收到历史数据的异常](MarkDown_Computer%20Networks.assets/1616140750-DgoGku-file_1616140748887)

如上图黄色框框服务端在关闭连接之前发送的 SEQ = 301 报文，被网络延迟了。
这时有相同端口的 TCP 连接被复用后，被延迟的 SEQ = 301 抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题。
所以，TCP 就设计出了这么一个机制，经过 **2MSL 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的**。



**原因二：保证连接正确关闭**

在 RFC 793 指出 TIME-WAIT 另一个重要的作用是：

TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.

也就是说，**TIME-WAIT 作用是等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭**。

假设 TIME-WAIT 没有等待时间或时间过短，断开连接会造成什么问题呢？

![没有确保正常断开的异常](MarkDown_Computer%20Networks.assets/1616140750-RVOwwL-file_1616140749008)



如果 TIME-WAIT 等待足够长的情况就会遇到两种情况：

服务端正常收到四次挥手的最后一个 ACK 报文，则服务端正常关闭连接。
服务端没有收到四次挥手的最后一个 ACK 报文时，则会重发 FIN 关闭连接报文并等待新的 ACK 报文。
所以客户端在 TIME-WAIT 状态等待 2MSL 时间后，就可以保证双方的连接都可以正常的关闭。



##### TIME_WAIT 过多有什么危害？

如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器方主动发起的断开请求。

过多的 TIME-WAIT 状态主要的危害有两种：

第一是内存资源占用；
第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口；
第二个危害是会造成严重的后果的，要知道，端口资源也是有限的，一般可以开启的端口为 32768～61000，也可以通过如下参数设置指定


net.ipv4.ip_local_port_range
如果发起连接一方的 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。

客户端受端口资源限制：

客户端TIME_WAIT过多，就会导致端口资源被占用，因为端口就65536个，被占满就会导致无法创建新的连接。
服务端受系统资源限制：

由于一个四元组表示 TCP 连接，理论上服务端可以建立很多连接，服务端确实只监听一个端口 但是会把连接扔给处理线程，所以理论上监听的端口可以继续监听。但是线程池处理不了那么多一直不断的连接了。所以当服务端出现大量 TIME_WAIT 时，系统资源被占满时，会导致处理不过来新的连接。





##### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。







- **协议**

HTTP
HTTPS
SSH
Telnet
FTP
SMTP





#### TCP拥塞控制

**拥塞**

即对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量（单位时间内成功地传送数据的数量（以比特、字节、分组等测量））随之负荷的增大而下降。

**定义**

TCP模块还有一个重要的任务，就是提高网络利用率，降低丢包率,并保证网络资源的对每条数据流的公平性。这就是所谓的拥塞控制。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。

**拥塞控制的目标**

·    提高网络利用率

·    降低丢包率

·    保证网络资源的对每条数据流的公平性

**拥塞控制的方法**

慢启动、拥塞避免、快速重传和快速恢复



**慢启动和拥塞避免**
MSS:报文段

RTT：往返时间 (表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认，不包含数据传输时间,总共经历的时间)。

SWND:发送窗口 (发送端向网络一次连续写入的数据量，窗口大小就是无需等待确认应答而可以继续发送数据的最大值）

CWND:拥塞窗口 指某一源端数据流在一个RTT内可以最多发送的数据包数

RWND：接收窗口

之前我已经介绍过滑动窗口，它的其中一个作用就是进行流量控制可以避免发送方过载接收方。但是却无法避免过载网络，这是因为接收窗口只反映了服务器个体的情况，却无法反映网络整体的情况。

发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。

发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。

**慢开始算法：**

拥塞窗口和接收窗口共同决定了发送者的发送窗口

当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。

较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值

通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。

![image-20210323173634381](MarkDown_Computer%20Networks.assets/image-20210323173634381.png)

如果不施加手段进行控制，慢启动必然使得CWBD很快膨胀，为防止拥塞窗口cwnd的增长引起网络拥塞，还需要另外一个变量，慢开始门限ssthresh
   
cwnd <ssthresh时,进行慢开始算法。  
cwnd>ssthresh时,进行拥塞避免算。
cwnd = ssthresh时,两者皆可

**拥塞避免算法：**

让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的cwnd 拥塞窗口cwnd加1cwnd ，而不是加倍cwnd 。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。
不论是慢开始还是拥塞避免只要网络出现拥塞（没有按时到达）时，就把ssthresh的值置为出现拥塞时的拥塞窗口的一半（但不能小于2），以及cwnd置为1，进行慢开始。 目的是迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。
注意：

由指数增长拉低到线性增长，降低出现拥塞的可能。“拥塞避免”并非指完全能够避免拥塞，利用以上的措施要完全避免网络拥塞还是不可能的。
![image-20210323173951793](MarkDown_Computer%20Networks.assets/image-20210323173951793.png)



**发送端判断拥塞发生的依据：**
1.传输超时（TCP重传定时器溢出）
2.接收到重复的确认报文段

以上是发送端在未检测到拥塞时所采用的积极避免拥塞的方法。接下来介绍拥塞发生时（可能发生在慢启动阶段或者拥塞避免阶段）拥塞控制的行为。



拥塞控制对这两种情况有不同的处理方式。**对第一种情况仍然使用慢启动和拥塞避免。对第二种情况使用快速重传和快速恢复（如果是真的发生拥塞的话）**，注意：第二种情况如果发生在第一种情况之后，则也被拥塞控制当成第一种情况来对待



**快速恢复和快速重传**
在很多情况下，发送端都有可能接收到重复的确认报文段，比如TCP报文端丢失，或者接收端收到乱序TCP报文段并重排之等。

拥塞控制算法需要判断当收到重复的确认报文端时，网络是否真的发生了阻塞，或者说TCP报文端是否真的丢失了。具体的做法是：发送端如果连续收到3个重复的确认报文端，就认为是拥塞发生了。然后它启用快速重传和快速恢复算法来处理拥塞。
![在这里插入图片描述](MarkDown_Computer%20Networks.assets/20180710115206319)



快速重传(Fast retransmit):要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。

如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK（其实是收到4个同样的ACK，第一个是正常的，后三个才是冗余的），发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出，大大提高了效率。这便是快速重传机制。

**快速恢复(Fast retransmit)具体过程**：

（1）当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。然后立即重传丢失的报文段，并将CWND设置为新的ssthresh（减半后的ssthresh）
请注意：接下去不执行慢开始算法

有些快重传实现是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3 * MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络 的资源而是停留在接收方的缓存中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大了些。

（2）由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。

(3)每次收到一个重复的确认时，设置CWND=CWND+SMSS（拥塞窗口加1）.此时发送端可以发送新的TCP报文段

(4)当收到新数据的确认时，设置CWND=ssthresh(ssthresh是新的慢启动门限值，由第一步计算得到)
原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。

快速重传和快速恢复完成之后，拥塞控制将恢复到拥塞避免阶段.


![image-20210323174459289](MarkDown_Computer%20Networks.assets/image-20210323174459289.png)

##### 总结

- 当出现**超时重传**和**冗余ack**的时候慢**启动门限都要设置为当前发送窗口的一半**
- 不同的就是**超时重传还得将拥塞窗口大小设为1，重新进入慢启动**，而**冗余ack则是将拥塞窗口设为慢启动门限大小并且进入拥塞避免**











### UDP

![image-20210323175800666](MarkDown_Computer%20Networks.assets/image-20210323175800666.png)

![image-20210323175924644](MarkDown_Computer%20Networks.assets/image-20210323175924644.png)![image-20210323175924760](MarkDown_Computer%20Networks.assets/image-20210323175924760.png)

**UDP数据报最大长度64K（包含UDP首部），如果数据长度超过64K就需要在应用层手动分包，UDP无法保证包序，需要在应用层进行编号。**

特点

无连接：知道对端的IP和端口号就直接进行传输, 不需要建立连接。
不可靠：没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层返回任何错误信息。面向数据报：不能够灵活的控制读写数据的次数和数量，应用层交给UDP多长的报文, UDP原样发送, 既不会拆分, 也不会合并。数据收不够灵活，但是能够明确区分两个数据包，避免粘包问题。

协议：

DHCP: 动态主机配置协议

DNS: 域名解析协议

BOOTP: 启动协议(用于无盘设备启动)

NFS: 网络文件系统

TFTP: 简单文件传输协议















### HTTP

```java
//TODO:
```







## 网络层







## 数据链路层







## 物理层

















